<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[点击显示/隐藏内容 1代码块测试 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo框架Next主题的个人博客（备忘录）]]></title>
    <url>%2FHexo%2F%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6Next%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%A4%87%E5%BF%98%E5%BD%95%EF%BC%89.html</url>
    <content type="text"><![CDATA[概述个人博客项目，使用Hexo静态博客框架创建，基于Next主题个性化定制，托管于代码托管平台的Pages服务上。 源码主要托管在 GitHub 远程仓库的source分支上；静态博客网页部署在 GitHub 远程仓库的master分支上，使用GitHub的Pages服务进行托管。 但是，受限于国内的网络环境原因，GitHub有时候会不能访问，或者网速实在“感人”。因此，需要同时将博客项目托管在国内的其他代码托管平台。 目前正在使用的代码托管平台为：Gitee（开源中国 oschina推出的基于Git的代码托管平台，个人有5G的免费私有仓库）和 Coding（现在使用的是腾讯云），同时，静态博客网页使用各自的Pages托管服务进行托管。 以下是我的个人博客项目在各个代码托管平台上远程仓库的项目地址和博客访问地址： GitHub远程仓库 项目地址：https://github.com/elinuxboy/elinuxboy.github.io 博客访问地址：https://elinuxboy.github.io Gitee远程仓库 项目地址：https://gitee.com/elinuxboy/elinuxboy 博客访问地址：https://elinuxboy.gitee.io Coding远程仓库 项目地址：https://dev.tencent.com/u/elinuxboy/p/elinuxboy.coding.me/git 博客访问地址：https://elinuxboy.coding.me 前提准备要使用Hexo创建博客项目，必须检查电脑中是否已安装下列应用程序： Node.js Git curl、tar 和 wget npm（国内使用 cnpm，即淘宝 npm 代替） Hexo 具体如何安装可以百度，或者参考：Hexo | 文档。 项目管理为了更好的进行管理和使用博客项目，需要使用git等工具对博客项目进行版本控制，并且将其托管在托管平台的远程仓库上。 已有项目对于已经托管在代码托管平台上的博客项目，或者在更换了不同电脑的情况下，只需要将项目克隆下来即可继续使用。 克隆项目以GitHub远程仓库为例，需要克隆source源码分支。 git clone -b source git@github.com:elinuxboy/elinuxboy.github.io.git 安装依赖模块对于重新克隆下来的博客项目，想要使用，需要重新安装依赖： cnpm install 这一步将会根据package.json文件安装所需要的模块。 新项目对于需要重新创建项目时，可以按照如下方式进行。 新建 Hexo 博客项目在工作空间创建并初始化Hexo博客项目，Hexo 将会新建所需要的文件： hexo init hexoBlog 点击显示/隐藏内容 1234567891011121314151617181920212223242526272829$ hexo init hexoBlogINFO Cloning hexo-starter to ~/workspace/blog/hexo/hexoBlog正克隆到 '/home/elinuxboy/workspace/blog/hexo/hexoBlog'...remote: Enumerating objects: 68, done.remote: Total 68 (delta 0), reused 0 (delta 0), pack-reused 68展开对象中: 100% (68/68), 完成.子模组 'themes/landscape'（https://github.com/hexojs/hexo-theme-landscape.git）未对路径 'themes/landscape' 注册正克隆到 '/home/elinuxboy/workspace/blog/hexo/hexoBlog/themes/landscape'...remote: Enumerating objects: 1, done. remote: Counting objects: 100% (1/1), done. remote: Total 867 (delta 0), reused 0 (delta 0), pack-reused 866 接收对象中: 100% (867/867), 2.55 MiB | 775.00 KiB/s, 完成.处理 delta 中: 100% (459/459), 完成.子模组路径 'themes/landscape'：检出 '73a23c51f8487cfcd7c6deec96ccc7543960d350'INFO Install dependenciesnpm WARN deprecated titlecase@1.1.2: no longer maintainednpm WARN deprecated postinstall-build@5.0.3: postinstall-build's behavior is now built into npm! You should migrate off of postinstall-build and use the new `prepare` lifecycle script with npm 5.0.0 or greater.&gt; nunjucks@3.1.6 postinstall /home/elinuxboy/workspace/blog/hexo/hexoBlog/node_modules/nunjucks&gt; node postinstall-build.js srcnpm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"linux","arch":"x64"&#125;)added 422 packages from 501 contributors and audited 4700 packages in 19.96sfound 0 vulnerabilitiesINFO Start blogging with Hexo! 进入 hexo 根目录。这一目录中应当有 node_modules、source、themes 等若干子目录和文件： cd hexoBlog 点击显示/隐藏内容 1234567891011121314.├── _config.yml* # 站点配置文件├── package.json* # 已安装模块信息文件├── package-lock.json*├── .gitignore # 版本控制忽略控制文件 ├── node_modules/ # 已安装`nodejs`模块文件夹├── scaffolds/ # 模板文件夹│ ├── draft.md* # 草稿模板文件│ ├── page.md* # 页面模板文件│ └── post.md* # 发布文章模板文件├── source/ # 资源文件夹│ └── _posts/ # 发布文章文件夹└── themes/ # 主题文件夹 └── landscape/ # landscape 主题文件夹 本地版本控制仓库初始化12$ git init已初始化空的 Git 仓库于 /home/elinuxboy/workspace/blog/hexo/hexoBlog/.git/ 查看git本地版本控制仓库状态： git status 点击显示/隐藏内容 1234567891011121314151617$ git status 位于分支 master尚无提交未跟踪的文件: （使用 "git add &lt;文件&gt;..." 以包含要提交的内容） .gitignore _config.yml package-lock.json package.json scaffolds/ source/ themes/提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪） git ignore 设置12345678$ cat .gitignore .DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 创建源码分支创建新分支source用于管理Hexo博客源码，并切换到source分支： 12$ git checkout -b source切换到一个新分支 'source 添加内容到暂存区git add . 提交暂存区的内容git commit -a 添加提交日志： 点击显示/隐藏内容 1234567初始提交新创建 Hexo 博客并初始化初始化本地版本控制仓库增加新分支 source 用于管理 Hexo 博客项目源码 远程版本控制仓库想要将博客项目托管在代码托管平台上，需要在代码托管平台上创建远程版本控制仓库并和本地版本控制仓库进行关联，然后推送本地版本控制仓库到远程仓库。 创建远程仓库 GitHub 创建名为elinuxboy.github.io空仓库。 Gitee 创建名为elinuxboy的空仓库。 Coding 创建名为elinuxboy.coding.me的空仓库。 添加远程仓库关联以Github代码托管平台为例，使用Github的远程仓库作为默认远程仓库，其他代码托管品台的远程仓库作为备用，需要按照如下方式添加远程仓库关联： git remote add origin git@github.com:elinuxboy/elinuxboy.github.io.git 再将其他托管平台的远程仓库作为push方式添加： git remote set-url --add origin git@gitee.com:elinuxboy/elinuxboy.git git remote set-url --add origin git@git.dev.tencent.com:elinuxboy/elinuxboy.coding.me.git 添加远程仓库关联完成后，可查看是否正确添加： 1234origin git@github.com:elinuxboy/elinuxboy.github.io.git (fetch)origin git@github.com:elinuxboy/elinuxboy.github.io.git (push)origin git@gitee.com:elinuxboy/elinuxboy.git (push)origin git@git.dev.tencent.com:elinuxboy/elinuxboy.coding.me.git (push) 如果使用其他托管平台作为默认远程仓库，方法与上面相同，只需要替换相应的地址即可。 推送源码到远程仓库上面已经将博客项目源码提交到本地版本控制仓库了，要将代码托管在托管平台，需要将本地版本控制仓库推送到代码托管平台的远程仓库。 查看当前所在的分支： 123$ git status 位于分支 source您的分支与上游分支 'origin/source' 一致。 将本地版本控制仓库的source分支推送到远程仓库的source分支： git push origin source 使用 Next 主题下载最新 release 版本选择好相应的 release 版本。使用 curl、tar 和 wget 安装(此处已加上版本号，使用时需要手动替换版本号)： 12$ mkdir themes/next-v6.6.0$ curl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next-v6.6.0 --strip-components=1 启用 Next 主题修改站点配置文件/_config.yml，启用Next主题： 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscapetheme: next-v6.6.0 # 启用 Next 主题 启用了Next主题后，就可以对Next主题进行相应的优化和个性化定制了。 以 Hexo 方式使用 Hexo 数据文件特性将全部配置都将置于hexo站点配置文件/_config.yml中，将主题配置文件的所有项复制到站点配置文件中进行修改，不需要修改主题配置文件/themes/next-xxx/_config.yml，或者创建其他的配置文件。但是所有的主题选项必须放置在 theme_config: 后，并全部增加两个空格的缩进。 如果在新的 release 中出现了任何新的选项，那么你只需要从 next/_config.yml 中将他们复制到 hexo/_config.yml 中并设置它们的值为你想要的选项。 远程部署上面已经将博客项目的源码推送到代码托管平台的远程版本控制仓库了，下面就是将博客静态网页相关文件部署到代码托管平台的远程仓库上了。 部署设置为了将博客静态站点部署到不同的代码托管平台，需要按照如下方式在配置文件内（站点配置文件）设置部署信息： 点击显示/隐藏内容 123456789101112131415# Deployment 远程部署设置## Docs: https://hexo.io/docs/deployment.htmldeploy: # github- type: git repo: git@github.com:elinuxboy/elinuxboy.github.io.git, branch: master # 部署到主分支 # coding- type: git repo: git@git.dev.tencent.com:elinuxboy/elinuxboy.coding.me.git branch: master # 部署到主分支 # gitee- type: git repo: git@gitee.com:elinuxboy/elinuxboy.git branch: master # 部署到主分支 安装部署插件修改了部署设置信息，想要使用hexo进行部署，还需要安装部署插件： cnpm install hexo-deployer-git --save 部署根据Hexo文档说明，使用以下命令进行部署(先清空后生成再部署)： hexo clean &amp;&amp; hexo g -d]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo框架Next主题的个人博客（文章内音乐播放和视频播放）]]></title>
    <url>%2FHexo%2F%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6Next%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%96%87%E7%AB%A0%E5%86%85%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%92%8C%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%EF%BC%89.html</url>
    <content type="text"><![CDATA[效果预览： 文章内添加音乐播放器： 文章内使用视频： (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"https://zhyong-cn-file.oss-cn-shanghai.aliyuncs.com/media%2F%E5%86%AF%E6%8F%90%E8%8E%AB%E3%80%8A%E7%BA%A2%E6%98%AD%E6%84%BF%E3%80%8B%5B%E8%BD%AF%E5%AD%97%E5%B9%95%5D.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音乐播放器插件一款好用的音乐播放器插件，通过对Meting API的引用，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。 github项目地址：https://github.com/MoePlayer/hexo-tag-aplayer 官方文档：https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md 安装：npm install --save hexo-tag-aplayer 在站点配置文件里添加如下的内容： 123# 文章内音乐播放器 不能在自定义配置文件里添加，只能在站点配置文件里添加aplayer: meting: true 使用示例： 12345&lt;!-- 简单示例 (id, server, type) --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;&lt;!-- 进阶示例 --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125; 有关选项表如下： 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置 视频播放插件Embed dplayer in Hexo posts/pages GitHub项目地址：https://github.com/MoePlayer/hexo-tag-dplayer 安装：npm install hexo-tag-dplayer --save 使用：在文章内调用no url specified, no dplayer _(:3」∠)_ 参考：https://github.com/MoePlayer/hexo-tag-dplayer/blob/master/README.md#usage]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>文章内音乐播放</tag>
        <tag>文章内视频播放</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro-xfce-18-踩坑记录]]></title>
    <url>%2FLinux%2Fmanjaro-xfce-18-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[简介Manjaro LinuxManjaro Linux是一个基于Arch Linux的发行版，继承了后者轻快、滚动式更新、AUR软件多的==优点==，同时又改善了后者对新手不友好、软件包过于激进、不够稳定的==缺点==，是最能拿来用、最好用的Linux发行版。 它不仅开箱即用，界面人性化，轻快不卡慢，稳定无崩溃，安静无弹窗，最最可喜的是软件超多！相信你用了Manjaro之后，再不会折腾、也不会再抛弃这个发行版了。 开发桌面环境这是我的 manjaro xfce 18 安装好以后的桌面使用情况： 点击显示/隐藏内容 12345678910111213141516171819# elinuxboy @ mjro18xfce in ~ [9:57:35] $ screenfetch ██████████████████ ████████ elinuxboy@mjro18xfce ██████████████████ ████████ OS: Manjaro 18.0 Illyria ██████████████████ ████████ Kernel: x86_64 Linux 4.19.8-2-MANJARO ██████████████████ ████████ Uptime: 1m ████████ ████████ Packages: 1301 ████████ ████████ ████████ Shell: zsh 5.6.2 ████████ ████████ ████████ Resolution: 1366x768 ████████ ████████ ████████ DE: Xfce4 ████████ ████████ ████████ WM: Xfwm4 ████████ ████████ ████████ WM Theme: Arc-Dark ████████ ████████ ████████ GTK Theme: Arc-Dark [GTK2] ████████ ████████ ████████ Icon Theme: Numix-Circle ████████ ████████ ████████ Font: 文泉驿微米黑 12 ████████ ████████ ████████ CPU: Intel Core i5-5200U @ 4x 2.7GHz [46.0°C] GPU: Mesa DRI Intel(R) HD Graphics 5500 (Broadwell GT2) RAM: 602MiB / 7892MiB 我对桌面环境的需求次序（优先级由高到低）： 系统性能好，占用资源少——》软件数量多——》对用户友好，易安装，易使用——》界面美观 性能 对系统性能的要求，必须要足够好，占用资源少，给开发留下的资源越多越好。 作为一个开发者（程序员），想要提工作高效率，对系统性能的要求几乎达到苛刻的地步。 因为开发者在处理一个问题时，动则要调用大量工具，或者同时打开十几、几十、上百个网页来搜索网上的解决方案，而firefox或chrome等上网工具都是吃内存大户（牺牲空间复杂度换来快速的时间复杂度），有时候必须牺牲一些后台程序以加快系统速度适应开发者的需要。 而Manjaro Linux发行版和Xfce桌面都具有快速、轻量、加载程序快速、占用的系统资源少的优点。 软件 为了节省不必要的折腾时间，开发者手头上的工具是越多越好、越容易获取越好。 centos、slackware这些软件奇缺或者需要非常复杂的途径才能找到安装源的系统就没必要尝试了。 ubuntu系软件比较丰富，但QQ/TIM这样的基本软件还需要折腾一番，还未必能稳定使用。 arch linux系软件包异常丰富，无情碾压deb和rpm系诸多发行版，例如manjaro下可以一条命令安装好无比稳定、功能全面的deepinwine-tim或deepinwine-qq。 对用户友好 对任何一个工作者来说，时间就是衡量一切价值的标准，节省时间就是延长生命尺度。拿archlinux为反面典型，虽然其性能高可以节省工作时间，但是如果安装它都要从头开始学习ABC，那价值就大打折扣。就安装系统的便捷性来说，archlinux、gentoo、lfs这样的系统真没必要尝试。 界面外观 为了性能，必须牺牲酷炫的外观，过炫的桌面影响桌面性能；但是过于简单的桌面需要花时间配置还不一定能完全配置好，也是影响工作效率。所以，外观普通即可，默认桌面选择xfce4、lxde、mate甚至仿制windows界面都是不错的。 综合考虑下，以下是我对一些发行版及桌面的排序（仅代表个人观点）： 发行版： manjaro——》mint——》ubuntu——》debian——》其他 桌面环境 xfce 4——》mate/gnome-classic——》cinnamon——》lxde——》其他 我选择的开发桌面环境： manjaro-xfce-18.0-stable（第一选择） linuxmint-19-xfce ubuntu-16.04.5-desktop 自动打开 NumLock确保已经安装 numlockx, 然后编辑 /etc/lightdm/lightdm.conf文件，在末尾添加以下几行: 12[Seat:*]greeter-setup-script=/usr/bin/numlockx on 系统快照安装timeshiftsudo pacman -S timeshift 使用timeshift创建系统快照 国内源设置manjaro官方软件仓库自动寻找最快的源sudo pacman-mirrors -i -c China -m rank 点击显示/隐藏内容 12345678910111213141516[elinuxboy@mjro18xfce ~]$ sudo pacman-mirrors -i -c China -m rank.: INFO Downloading mirrors from repo.manjaro.org.: INFO Using default mirror file.: INFO Querying mirrors - This may take some time 0.867 China : https://mirrors.ustc.edu.cn/manjaro/ 0.557 China : http://mirrors.tuna.tsinghua.edu.cn/manjaro/ 0.861 China : https://mirrors.zju.edu.cn/manjaro/ 0.727 China : https://mirrors.sjtug.sjtu.edu.cn/manjaro/.: INFO User generated mirror list--.: INFO Custom mirror file saved: /var/lib/pacman-mirrors/custom-mirrors.json.: INFO Writing mirror list China : http://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$a.: INFO Mirror list generated and saved to: /etc/pacman.d/mirrorlist[elinuxboy@mjro18xfce ~]$ 选择源在弹出窗口中选择排第一位的源（这里选择清华大学tsinghua的源）然后点击“OK”，再次单击“确定”即可选择好最快的源。 更新源sudo pacman -Sy 非官方仓库（Arch Linux 中文社区仓库）Arch Linux 中文社区仓库 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含中文用户常用软件、工具、字体/美化包等。 完整的包信息列表（包名称/架构/维护者/状态）请 点击这里 查看。 官方仓库地址：http://repo.archlinuxcn.org 镜像地址: https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/ 手动添加archlinuxcn清华源sudo vim /etc/pacman.conf 用上面的命令编辑/etc/pacman.conf，在最下方添加（这里使用清华大学的源）： 12[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 详情参见附录I。 更新源sudo pacman -Sy 安装archlinuxcn-keyring包导入GPG key：sudo pacman -S archlinuxcn-keyring 再次更新源sudo pacman -Sy 安装yaourt以及pacaur为了安装使用AUR方便，也可以额外安装yaourt以及pacaur sudo pacman -S yaourt pacaur 注意：使用使用yaourt安装软件时： a.不需要使用sudo否则报root错误； b.在提示调用vim时 输入vim然后回车； c.如果不想输入vim: 修改~/.zshrc 文件文件最后加入export VISUAL=“vim” 即可。 软件安装时下载加速设置替换wget或者curl下载命令。以下在配置时，aria2c和axel使用其中一种即可（这里使用aria2c）。 使用aria2c多线程多链接加速aria2c 是一个自由、开源、轻量级多协议和多源的命令行下载工具。 aria2c 支持 HTTP/HTTPS、FTP、SFTP、 BitTorrent 和 Metalink 协议。 aria2c 可以通过内建的 JSON-RPC 和 XML-RPC 接口来操纵。 aria2c 下载文件的时候，自动验证数据块。它可以通过多个来源或者多个协议下载一个文件，并且会尝试利用你的最大下载带宽。 aria2c 支持多线程，可以使用多个源或协议下载文件，确实可以加速并尽可能多的完成下载。 安装aria2csudo pacman -Sy aria2c 配置pacman多线程多链接加速编辑pacman配置文件/etc/pacman.conf，找到Xfercommand修改成如下： 1234......# aria2c 多线程多链接XferCommand = /usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 -d $(dirname %o) -o $(basename %o) %u...... 配置yaourt多线程多链接加速编辑makepkg配置文件/etc/makepkg.conf，找到DLAGENTS修改成如下 点击显示/隐藏内容 123456789101112131415...#DLAGENTS=('file::/usr/bin/curl -gqC - -o %o %u'# 'ftp::/usr/bin/curl -gqfC - --ftp-pasv --retry 3 --retry-delay 3 -o %o %u'# 'http::/usr/bin/curl -gqb "" -fLC - --retry 3 --retry-delay 3 -o %o %u'# 'https::/usr/bin/curl -gqb "" -fLC - --retry 3 --retry-delay 3 -o %o %u'# 'rsync::/usr/bin/rsync --no-motd -z %u %o'# 'scp::/usr/bin/scp -C %u %o')#aria2c 多线程多链接DLAGENTS=('file::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'ftp::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'http::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'https::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'rsync::/usr/bin/rsync --no-motd -z %u %o' 'scp::/usr/bin/scp -C %u %o')... 详情请参见附录II。 使用Axel单线程多链接加速Axel 是一个轻量级下载程序，它和其他加速器一样，对同一个文件建立多个连接，每个连接下载单独的文件片段以更快地完成下载。 Axel 支持 HTTP、HTTPS、FTP 和 FTPS 协议。它也可以使用多个镜像站点下载单个文件，所以，Axel 可以加速下载高达 40％（大约，我个人认为）。它非常轻量级，因为它没有依赖并且使用非常少的 CPU 和内存。 Axel 一步到位地将所有数据直接下载到目标文件（LCTT 译注：而不是像其它的下载软件那样下载成多个文件块，然后拼接）。 注意：不支持在单条命令中下载两个文件。 安装axelsudo pacman -S axel 配置pacman单线程多链接加速编辑pacman配置文件/etc/pacman.conf，找到Xfercommand修改成如下： 1234......# axel 单线程多链接XferCommand = /usr/bin/axel -a -n 16 %u -o %o...... 配置yaourt单线程多链接加速编辑makepkg配置文件/etc/makepkg.conf，找到DLAGENTS修改成如下 点击显示/隐藏内容 123456789101112131415......#DLAGENTS=('file::/usr/bin/curl -gqC - -o %o %u'# 'ftp::/usr/bin/curl -gqfC - --ftp-pasv --retry 3 --retry-delay 3 -o %o %u'# 'http::/usr/bin/curl -gqb "" -fLC - --retry 3 --retry-delay 3 -o %o %u'# 'https::/usr/bin/curl -gqb "" -fLC - --retry 3 --retry-delay 3 -o %o %u'# 'rsync::/usr/bin/rsync --no-motd -z %u %o'# 'scp::/usr/bin/scp -C %u %o')#axel 单线程多链接DLAGENTS=('file::/usr/bin/axel -a -n 16 %u -o %o' 'ftp::/usr/bin/axel -a -n 16 %u -o %o' 'http::/usr/bin/axel -a -n 16 %u -o %o' 'https::/usr/bin/axel -a -n 16 %u -o %o' 'rsync::/usr/bin/rsync --no-motd -z %u %o' 'scp::/usr/bin/scp -C %u %o')...... 然后更新数据源sudo pacman -Syy 安装被锁定的问题注意：出现无法锁定database的错误时，在确认没有安装任务时运行以下命令删除锁定： sudo rm /var/lib/pacman/db.lck 升级系统sudo pacman -Syu 或者 yaourt -Syu 常见的软件安装pacman 基本用法安装软件1234567891011# 安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：sudo pacman -S pkg_name1 pkg_name2 ...# 安装一个本地包(不从源里下载）：sudo pacman -U /path/to/package/package_name-version.pkg.tar.xz# 安装一个远程包（不在 pacman 配置的源里面）：sudo pacman -U http://www.example.com/repo/example.pkg.tar.xz# 下载包而不安装它：sudo pacman -Sw pkg_name 删除软件123456789101112# 删除指定安装包，但是保留其全部已安装的依赖关系sudo pacman -R pkg_name # 删除指定软件包，以及没有被其他已安装软件包使用的依赖关系。 sudo pacman -Rs pkg_name # 删除软件包和所有依赖这个软件包的程序:# 警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。sudo pacman -Rsc pkg_name# 删除软件包，但是不删除依赖这个软件包的其他程序：sudo pacman -Rdd pkg_name 清空缓存12# 清除未安装软件包的缓存 sudo pacman -Sc 查询1234567891011121314151617181920# 在包数据库中查询软件包，查询位置包含了软件包的名字和描述(不指定string，则列出所有已安装的包)：pacman -Ss string1 string2 ...# 查询包含某个文件的包名 pacman -Fs pkg_name# 查询远程库中软件包包含的文件：pacman -Fl pkg_name# 获取已安装软件包所包含文件的列表：pacman -Ql pkg_name# 查询已安装的软件包(不指定string，则列出所有已安装的包)：pacman -Qs string1 string2 ...# 显示软件包的详尽的信息：sudo pacman -Si pkg_name# 查询本地安装包的详细信息：sudo pacman -Qi pkg_name 同步文件数据库12# 同步文件数据库:sudo pacman -Fy 升级系统12345678# 升级整个系统,这个命令会同步非本地(local)软件仓库并升级系统的软件包：sudo pacman -Syu# 升级系统时安装其他软件包：sudo pacman -Syu pkg_name1 pkg_name2 ...# 强制 pacman 刷新软件包列表，每次修改镜像之后都应该使用sudo pacman -Syyu 安装中文输入法 安装小企鹅fcitx： fcitx安装后会默认安装了拼音和五笔输入法。 sudo pacman -S fcitx fcitx-im fcitx-configtool 需要修改配置文件 ~/.xprofile，添加如下语句： 1234#fcitxexport GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS="@im=fcitx" 安装其他中文输入法 搜狗拼音输入法 sudo pacman -S fcitx-sogoupinyin 启动fcitx并设置输入法之后就可以使用中文输入法啦，如果异常请重新登录或者重启！！ 安装字体sudo pacman -S ttf-dejavu wqy-zenhei wqy-microhei ttf-monaco 要使用新安装的字体，需要再设置里自行选择。 设置——》外观——》字体——》选择默认字体和默认等宽字体 安装vimsudo pacman -S vim 超强vim配置项目地址：https://github.com/elinuxboy/vim-deprecated 使用下面的命令自动安装配置： wget -qO- https://raw.githubusercontent.com/elinuxboy/vim-deprecated/master/setup.sh | sh -x 或者用另一种方式自动安装： 123wget https://raw.githubusercontent.com/elinuxboy/vim-deprecated/master/setup.shchmod +x setup.sh./setup.sh 安装markdown编辑器以下只需要使用其中一种或几种。 yaourt -S typora（推荐使用） sudo pacman -S remarkable yaourt -S haroopad sudo pacman -S retext 安装gitsudo pacman -S git 设置个人github信息 git config --global user.name &quot;github昵称&quot; git config --global user.email &quot;注册邮箱&quot; 安装smartGit一个Git客户端。archlinux/manjaro的主源里就有它。 yaout -S smartgit 安装图形化的解压软件sudo pacman -S p7zip file-roller unrar 安装bat替代catsudo pacman -S bat 安装护眼软件红移redshiftsudo pacman -S redshift 安装gnome磁盘管理sudo pacman -S gnome-disk-utility 安装截图软件（可编辑）yaourt -S hotshots 注意：因为网络问题，这里可能需要对PKGBUILD做一些修改，将http改为https。 安装google浏览器sudo pacman -S google-chrome 安装uGetLinux 下最好的下载管理器 sudo pacman -S uget 安装网易云音乐yaourt -S netease-cloud-music 安装osdlyrics（本地音乐播放器显示歌词需要）sudo pacman -S osdlyrics 安装WPS-officesudo pacman -S wps-office 安装有道词典有道词典。 yaourt -S youdao-dict 安装ClamAVClam 防病毒软件（命令行） sudo pacman -S clamav Clam 防病毒软件（客户端） sudo pacman -S clamtk 安装sublime-text-3输入法修复版本 yaourt -S sublime-text-3-imfix 如果默认的拼音输入法还是无法使用，需要安装其他中文输入法。如谷歌拼音/搜狗拼音等。 安装虚拟机yaourt -S vmware-workstation 注意：如果出现vmmod找不到的问题，需要安装linux-headers后再一次安装，之后重新登陆后即可。 安装QQyaourt -S deepin.com.qq.im 安装Timyaourt -S deepin.com.qq.office 安装微信微信，公认最好的，是electronic-wechat。 命令直接安装yaourt -S electronic-wechat 源码编译安装在下载和运行这个项目之前，你需要在电脑上安装 Git 和 Node.js (来自 npm)。在命令行中输入: 下载仓库 git clone https://github.com/geeeeeeeeek/electronic-wechat.git 进入源码目录 cd electronic-wechat 安装, 运行应用 sudo npm install &amp;&amp; sudo npm start 根据你的平台打包应用: sudo npm run build:linux 使用发布版开箱即用的稳定版应用 123tar xvf electronic-wechat-linux-x64.tar.gzcd electronic-wechat-linux-x64./electronic-wechat %U 可以给他添加快捷方式 安装oh my zsh查看系统是否安装了zshcat /etc/shells 12345678# Pathnames of valid login shells.# See shells(5) for details./bin/sh/bin/bash/bin/zsh/usr/bin/zsh/usr/bin/git-shell 如果已经安装zsh,则会多出来以下条目 12/bin/zsh/usr/bin/zsh 查看系统当前使用的shell12$ echo $SHELL/bin/bash 切换shell为zsh$ chsh -s /bin/zsh 如果要切换回去bash： chsh -s /bin/bash 重启生效,如下所示: 点击显示/隐藏内容 12345678910111213141516171819......This is the Z Shell configuration function for new users,zsh-newuser-install.You are seeing this message because you have no zsh startup files(the files .zshenv, .zprofile, .zshrc, .zlogin in the directory~). This function can help you with a few settings that shouldmake your use of the shell easier.You can:(q) Quit and do nothing. The function will be run again next time.(0) Exit, creating the file ~/.zshrc containing just a comment. That will prevent this function being run again.(1) Continue to the main menu.--- Type one of the keys in parentheses --- 0mjroXfce18% 查看当前shell $ echo $SHELL 1/bin/zsh 下载安装 oh my zshwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 完成后如下所示: 点击显示/隐藏内容 123456789101112131415161718......Looking for an existing zsh config...Found ~/.zshrc. Backing up to ~/.zshrc.pre-oh-my-zshUsing the Oh My Zsh template file and adding it to ~/.zshrc __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \ / /_/ / / / / / / / / / / /_/ / / /_(__ ) / / / \____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at https://shop.planetargon.com.mjroXfce18% 配置oh my zsh 安装autojump自动跳转插件 123sudo pacman -S autojumpecho ". /usr/share/autojump/autojump.zsh" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrcsource .zshrc 安装zsh-syntax-highlighting语法高亮插件 123git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlightingecho "source $ZSH_CUSTOM/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrcsource .zshrc 安装zsh-autosuggestions语法历史记录插件 123git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestionsecho "source $ZSH_CUSTOM/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrcsource .zshrc 安装自动补全插件incr 123456cd $ZSH_CUSTOM/pluginsmkdir incrcd incrwget http://mimosa-pudica.net/src/incr-0.2.zshecho "source $ZSH_CUSTOM/plugins/incr/incr*.zsh" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrcsource .zshrc 详细的.zshrc请参见附录IV。 修改主题 修改.zshrc文件 1vim ~.zshrc 找到ZSH_THEME=“robbyrussell”，修改为：ZSH_THEME=“ys”； 123......ZSH_THEME="ys"...... 更新配置 1source .zshrc XFCE图标主题美化安装图标yaourt -S numix-circle-icon-theme-git sudo pacman -S papirus-icon-theme 安装主题sudo pacman -S arc-gtk-theme 设置 主题：设置——》外观——》样式——》arc 图标：设置——》外观——》图标——》numix circle 优化系统启动速度Arch Linux 的 systemd-analyze 是个很不错的工具，利用它你可以很直观地观察到系统启动的时间都花到哪儿去了： systemd-analyze 我注意到打开 AHCI 后，内核和用户空间的载入速度明显提高了，总启动时间从约 30 秒缩短到 20 秒，效果非常明显。 用下面这个命令，可以了解到是什么东西启动最慢： systemd-analyze blame 此外，还可以把启动过程绘制成 SVG 图表供你审阅（用 GNOME 的图片预览或 Chrome 浏览器都可以打开），这个图表中你还可以观察到是否有启动慢的组件影响到了依赖它的组件的启动： systemd-analyze plot &gt; plot.svg 将npm的注册表源设置为国内的镜像国内用户，建议将npm的注册表源设置为国内的镜像，可以大幅提升安装速度。 淘宝npm镜像 搜索地址：http://npm.taobao.org/ registry地址：http://registry.npm.taobao.org/ cnpmjs镜像 搜索地址：http://cnpmjs.org/ registry地址：http://r.cnpmjs.org/ 临时使用 npm --registry https://registry.npm.taobao.org install express 持久使用 npm config set registry https://registry.npm.taobao.org 配置后可通过下面方式来验证是否成功npm config get registry或npm info express 通过cnpm(可能需要加上sudo) npm install -g cnpm --registry=https://registry.npm.taobao.org 使用cnpm install express 我使用的是cnpm.如下图: 问题与解决安装中遇到的问题 安装时一直停在“正在加载位置数据” 解决办法：先把网络连接都断开，再启动安装，等地图位置加载完成后，再联网继续安装。 警告：xxx本地比xxx的版本更新例如，加入archlinuxcn中文社区库后，执行sudo pacman -Syu升级系统后，出现如下问题： 1234567......警告：cower：本地 (18-2) 比 extra 的版本更新 (18-1)警告：inxi：本地 (3.0.29-1) 比 community 的版本更新 (3.0.28-1)警告：lib32-qt4：本地 (4.8.7-14) 比 multilib 的版本更新 (4.8.7-13)警告：libxpresent：本地 (1.0.0+3+g9d31d21-1) 比 extra 的版本更新 (1.0.0+2+gdd6771c-1)警告：package-query：本地 (1.9-3) 比 extra 的版本更新 (1.9-2)...... 解决办法该问题一般出现在：启用了多个镜像（比如同时使用manjaro官方库和archlinuxcn中文社区库），或者刚切换了镜像，然后执行升级系统命令。 该问题可以忽略，因为archlinuxcn中文社区库里面的版本要比manjaro官方库里面的版本更新，升级后本地的版本就是使用archlinuxcn中文社区库里面的最新版本。 例如： 12345$ pacman -Ss cowerextra/cower 18-1 [已安装: 18-2] A simple AUR agent with a pretentious namearchlinuxcn/cower 18-2 [已安装] A simple AUR agent with a pretentious name 当然，也可以给软件包降级： 使用pacman的临时文件（安装本地包）降级 如果一个新包刚刚被安装并且没有删除pacman cache,你可以在/var/cache/pacman/pkg/中找到较早版本. 安装替换现有的版本. pacman会处理依赖包但不会处理依赖库的版本冲突。如果一个其依赖库因该包降级需要降级，你需要手动降级这些包。 pacman -U /var/cache/pacman/pkg/package-old_version.pkg.tar.xz 使用远程包（安装远程包）降级 pacman -U http://www.example.com/repo/package-old_version.pkg.tar.xz aria2c下载xxx.db.sig出现错误点击显示/隐藏内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# elinuxboy @ mjro18xfce in ~ [7:53:20] $ sudo pacman -Sy[sudo] elinuxboy 的密码：:: 正在同步软件包数据库...12/15 07:53:25 [NOTICE] Downloading 1 item(s)12/15 07:53:26 [NOTICE] 下载已完成：/var/lib/pacman/sync/core.db.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================e48729|OK | 589KiB/s|/var/lib/pacman/sync/core.db.part状态标识：(OK)：下载已完成。12/15 07:53:26 [NOTICE] Downloading 1 item(s)12/15 07:53:26 [ERROR] CUID#7 - Download aborted. URI=https://mirrors.ustc.edu.cn/manjaro/stable/core/x86_64/core.db.sigException: [AbstractCommand.cc:351] errorCode=3 URI=https://mirrors.ustc.edu.cn/manjaro/stable/core/x86_64/core.db.sig -&gt; [HttpSkipResponseCommand.cc:219] errorCode=3 未找到资源12/15 07:53:26 [NOTICE] GID 为 3ec1fe753480d611 的下载项未完成：/var/lib/pacman/sync/core.db.sig.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================3ec1fe|ERR | 0B/s|/var/lib/pacman/sync/core.db.sig.part状态标识：(ERR)：发生错误。重新启动aria2，自动继续下载文件如果发生任何错误，请参阅日志文件。要了解详细信息，请在 help/man 页面中参阅“-l”选项。12/15 07:53:28 [NOTICE] Downloading 1 item(s)[#58174d 1.7MiB/1.8MiB(95%) CN:1 DL:1.0MiB] 12/15 07:53:30 [NOTICE] 下载已完成：/var/lib/pacman/sync/extra.db.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================58174d|OK | 1.0MiB/s|/var/lib/pacman/sync/extra.db.part状态标识：(OK)：下载已完成。12/15 07:53:30 [NOTICE] Downloading 1 item(s)12/15 07:53:31 [ERROR] CUID#7 - Download aborted. URI=https://mirrors.ustc.edu.cn/manjaro/stable/extra/x86_64/extra.db.sigException: [AbstractCommand.cc:351] errorCode=3 URI=https://mirrors.ustc.edu.cn/manjaro/stable/extra/x86_64/extra.db.sig -&gt; [HttpSkipResponseCommand.cc:219] errorCode=3 未找到资源12/15 07:53:31 [NOTICE] GID 为 5da8892ce4724c98 的下载项未完成：/var/lib/pacman/sync/extra.db.sig.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================5da889|ERR | 0B/s|/var/lib/pacman/sync/extra.db.sig.part状态标识：(ERR)：发生错误。重新启动aria2，自动继续下载文件如果发生任何错误，请参阅日志文件。要了解详细信息，请在 help/man 页面中参阅“-l”选项。12/15 07:53:33 [NOTICE] Downloading 1 item(s)[#d66d80 4.5MiB/5.0MiB(90%) CN:1 DL:0.9MiB] 12/15 07:53:38 [NOTICE] 下载已完成：/var/lib/pacman/sync/community.db.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================d66d80|OK | 1.0MiB/s|/var/lib/pacman/sync/community.db.part状态标识：(OK)：下载已完成。12/15 07:53:38 [NOTICE] Downloading 1 item(s)12/15 07:53:38 [ERROR] CUID#7 - Download aborted. URI=https://mirrors.ustc.edu.cn/manjaro/stable/community/x86_64/community.db.sigException: [AbstractCommand.cc:351] errorCode=3 URI=https://mirrors.ustc.edu.cn/manjaro/stable/community/x86_64/community.db.sig -&gt; [HttpSkipResponseCommand.cc:219] errorCode=3 未找到资源12/15 07:53:38 [NOTICE] GID 为 44b66925e8f1286f 的下载项未完成：/var/lib/pacman/sync/community.db.sig.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================44b669|ERR | 0B/s|/var/lib/pacman/sync/community.db.sig.part状态标识：(ERR)：发生错误。重新启动aria2，自动继续下载文件如果发生任何错误，请参阅日志文件。要了解详细信息，请在 help/man 页面中参阅“-l”选项。12/15 07:53:40 [NOTICE] Downloading 1 item(s)12/15 07:53:41 [NOTICE] 下载已完成：/var/lib/pacman/sync/multilib.db.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================a00c29|OK | 722KiB/s|/var/lib/pacman/sync/multilib.db.part状态标识：(OK)：下载已完成。12/15 07:53:41 [NOTICE] Downloading 1 item(s)12/15 07:53:41 [ERROR] CUID#7 - Download aborted. URI=https://mirrors.ustc.edu.cn/manjaro/stable/multilib/x86_64/multilib.db.sigException: [AbstractCommand.cc:351] errorCode=3 URI=https://mirrors.ustc.edu.cn/manjaro/stable/multilib/x86_64/multilib.db.sig -&gt; [HttpSkipResponseCommand.cc:219] errorCode=3 未找到资源12/15 07:53:41 [NOTICE] GID 为 96eb7b68d9be8b5d 的下载项未完成：/var/lib/pacman/sync/multilib.db.sig.part下载结果：gid |stat|avg speed |path/URI======+====+===========+=======================================================96eb7b|ERR | 0B/s|/var/lib/pacman/sync/multilib.db.sig.part状态标识：(ERR)：发生错误。重新启动aria2，自动继续下载文件如果发生任何错误，请参阅日志文件。要了解详细信息，请在 help/man 页面中参阅“-l”选项。 解决办法xxx.db.sig 缺失是 database 的签名缺失，这是正常的，现在都只验证 package 的签名，database 都不签名了。 在官方仓库和archlinuxcn中文社区库里已经没有xxx.db.sig文件了，所以当然下载不到。 错误：无法注册 ‘archlinuxcn’ 数据库 (数据库已登记)123456789......error: could not register 'archlinuxcn' database (database already registered)error: could not register 'archlinuxcn' database (database already registered)error: could not register 'archlinuxcn' database (database already registered)could not register 'archlinuxcn' database (database already registered)错误：无法注册 'archlinuxcn' 数据库 (数据库已登记)错误：无法注册 'archlinuxcn' 数据库 (数据库已登记)错误：无法注册 'archlinuxcn' 数据库 (数据库已登记)...... 该问题一般出现在添加archlinuxcn中文社区库的时候添加错文件了，应该是在这个文件“==/etc/pacman.conf==”后面添加archlinuxcn中文社区库，而不是在这个“/etc/pacman.d/mirrorlist”文件后添加。 附录I：/etc/pacman.conf点击显示/隐藏内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108## /etc/pacman.conf## See the pacman.conf(5) manpage for option and repository directives## GENERAL OPTIONS#[options]# The following paths are commented out with their default values listed.# If you wish to use different paths, uncomment and update the paths.#RootDir = /#DBPath = /var/lib/pacman/CacheDir = /var/cache/pacman/pkg/#LogFile = /var/log/pacman.log#GPGDir = /etc/pacman.d/gnupg/#HookDir = /etc/pacman.d/hooks/HoldPkg = pacman glibc manjaro-system# If upgrades are available for these packages they will be asked for firstSyncFirst = manjaro-system archlinux-keyring manjaro-keyring#XferCommand = /usr/bin/curl -C - -f %u &gt; %o#XferCommand = /usr/bin/wget --passive-ftp -c -O %o %u# aria2c 多线程多链接#XferCommand = /usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 -d $(dirname %o) -o $(basename %o) %u#CleanMethod = KeepInstalled#UseDelta = 0.7Architecture = auto# 下载进度条吃豆子方式ILoveCandy# Pacman won't upgrade packages listed in IgnorePkg and members of IgnoreGroup#IgnorePkg =#IgnoreGroup =#NoUpgrade =#NoExtract =# Misc options#UseSyslog# 彩色输出Color#TotalDownload# We cannot check disk space from within a chroot environmentCheckSpace# 升级前对比版本VerbosePkgLists # By default, pacman accepts packages signed by keys that its local keyring# trusts (see pacman-key and its man page), as well as unsigned packages.SigLevel = Required DatabaseOptionalLocalFileSigLevel = Optional#RemoteFileSigLevel = Required # NOTE: You must run `pacman-key --init` before first using pacman; the local# keyring can then be populated with the keys of all official Manjaro Linux# packagers with `pacman-key --populate archlinux manjaro`. ## REPOSITORIES# - can be defined here or included from another file# - pacman will search repositories in the order defined here# - local/custom mirrors can be added here or in separate files# - repositories listed first will take precedence when packages# have identical names, regardless of version number# - URLs will have $repo replaced by the name of the current repo# - URLs will have $arch replaced by the name of the architecture## Repository entries are of the format:# [repo-name]# Server = ServerName# Include = IncludePath## The header [repo-name] is crucial - it must be present and# uncommented to enable the repo.# # The testing repositories are disabled by default. To enable, uncomment the# repo name header and Include lines. You can add preferred servers immediately# after the header, and they will be used before the default mirrors. [core]SigLevel = PackageRequiredInclude = /etc/pacman.d/mirrorlist [extra]SigLevel = PackageRequiredInclude = /etc/pacman.d/mirrorlist [community]SigLevel = PackageRequiredInclude = /etc/pacman.d/mirrorlist # If you want to run 32 bit applications on your x86_64 system,# enable the multilib repositories as required here. [multilib]SigLevel = PackageRequiredInclude = /etc/pacman.d/mirrorlist # An example of a custom package repository. See the pacman manpage for# tips on creating your own repositories.#[custom]#SigLevel = Optional TrustAll#Server = file:///home/custompkgs # archlinuxcn中文社区库清华大学镜像[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 附录II：/etc/makepkg.conf点击显示/隐藏内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162## /etc/makepkg.conf# ########################################################################## SOURCE ACQUISITION###########################################################################-- The download utilities that makepkg should use to acquire sources# Format: 'protocol::agent'#DLAGENTS=('file::/usr/bin/curl -gqC - -o %o %u'# 'ftp::/usr/bin/curl -gqfC - --ftp-pasv --retry 3 --retry-delay 3 -o %o %u'# 'http::/usr/bin/curl -gqb "" -fLC - --retry 3 --retry-delay 3 -o %o %u'# 'https::/usr/bin/curl -gqb "" -fLC - --retry 3 --retry-delay 3 -o %o %u'# 'rsync::/usr/bin/rsync --no-motd -z %u %o'# 'scp::/usr/bin/scp -C %u %o') # axel 单线程多链接#DLAGENTS=('file::/usr/bin/axel -a -n 16 %u -o %o'# 'ftp::/usr/bin/axel -a -n 16 %u -o %o'# 'http::/usr/bin/axel -a -n 16 %u -o %o'# 'https::/usr/bin/axel -a -n 16 %u -o %o'# 'rsync::/usr/bin/rsync --no-motd -z %u %o'# 'scp::/usr/bin/scp -C %u %o') # aria2c 多线程多链接DLAGENTS=('file::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'ftp::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'http::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'https::/usr/bin/aria2c --allow-overwrite=true --log-level=error -l aria2c-error.log -c -m2 -x 8 -s 8 -j 8 %u -o %o' 'rsync::/usr/bin/rsync --no-motd -z %u %o' 'scp::/usr/bin/scp -C %u %o') # Other common tools:# /usr/bin/snarf# /usr/bin/lftpget -c# /usr/bin/wget #-- The package required by makepkg to download VCS sources# Format: 'protocol::package'VCSCLIENTS=('bzr::bzr' 'git::git' 'hg::mercurial' 'svn::subversion') ########################################################################## ARCHITECTURE, COMPILE FLAGS##########################################################################CARCH="x86_64"CHOST="x86_64-pc-linux-gnu" #-- Compiler and Linker Flags# -march (or -mcpu) builds exclusively for an architecture# -mtune optimizes for an architecture, but builds for whole processor familyCPPFLAGS="-D_FORTIFY_SOURCE=2"CFLAGS="-march=x86-64 -mtune=generic -O2 -pipe -fstack-protector-strong -fno-plt"CXXFLAGS="-march=x86-64 -mtune=generic -O2 -pipe -fstack-protector-strong -fno-plt"LDFLAGS="-Wl,-O1,--sort-common,--as-needed,-z,relro,-z,now"#-- Make Flags: change this for DistCC/SMP systems#MAKEFLAGS="-j2"#-- Debugging flagsDEBUG_CFLAGS="-g -fvar-tracking-assignments"DEBUG_CXXFLAGS="-g -fvar-tracking-assignments" ########################################################################## BUILD ENVIRONMENT########################################################################### Defaults: BUILDENV=(!distcc color !ccache check !sign)# A negated environment option will do the opposite of the comments below.##-- distcc: Use the Distributed C/C++/ObjC compiler#-- color: Colorize output messages#-- ccache: Use ccache to cache compilation#-- check: Run the check() function if present in the PKGBUILD#-- sign: Generate PGP signature file#BUILDENV=(!distcc color !ccache check !sign)##-- If using DistCC, your MAKEFLAGS will also need modification. In addition,#-- specify a space-delimited list of hosts running in the DistCC cluster.#DISTCC_HOSTS=""##-- Specify a directory for package building.#BUILDDIR=/tmp/makepkg ########################################################################## GLOBAL PACKAGE OPTIONS# These are default values for the options=() settings########################################################################### Default: OPTIONS=(!strip docs libtool staticlibs emptydirs !zipman !purge !debug)# A negated option will do the opposite of the comments below.##-- strip: Strip symbols from binaries/libraries#-- docs: Save doc directories specified by DOC_DIRS#-- libtool: Leave libtool (.la) files in packages#-- staticlibs: Leave static library (.a) files in packages#-- emptydirs: Leave empty directories in packages#-- zipman: Compress manual (man and info) pages in MAN_DIRS with gzip#-- purge: Remove files specified by PURGE_TARGETS#-- debug: Add debugging flags as specified in DEBUG_* variables#OPTIONS=(strip docs !libtool !staticlibs emptydirs zipman purge !debug) #-- File integrity checks to use. Valid: md5, sha1, sha256, sha384, sha512INTEGRITY_CHECK=(md5)#-- Options to be used when stripping binaries. See `man strip' for details.STRIP_BINARIES="--strip-all"#-- Options to be used when stripping shared libraries. See `man strip' for details.STRIP_SHARED="--strip-unneeded"#-- Options to be used when stripping static libraries. See `man strip' for details.STRIP_STATIC="--strip-debug"#-- Manual (man and info) directories to compress (if zipman is specified)MAN_DIRS=(&#123;usr&#123;,/local&#125;&#123;,/share&#125;,opt/*&#125;/&#123;man,info&#125;)#-- Doc directories to remove (if !docs is specified)DOC_DIRS=(usr/&#123;,local/&#125;&#123;,share/&#125;&#123;doc,gtk-doc&#125; opt/*/&#123;doc,gtk-doc&#125;)#-- Files to be removed from all packages (if purge is specified)PURGE_TARGETS=(usr/&#123;,share&#125;/info/dir .packlist *.pod)#-- Directory to store source code in for debug packagesDBGSRCDIR="/usr/src/debug" ########################################################################## PACKAGE OUTPUT########################################################################### Default: put built package and cached source in build directory##-- Destination: specify a fixed directory where all packages will be placed#PKGDEST=/home/packages#-- Source cache: specify a fixed directory where source files will be cached#SRCDEST=/home/sources#-- Source packages: specify a fixed directory where all src packages will be placed#SRCPKGDEST=/home/srcpackages#-- Log files: specify a fixed directory where all log files will be placed#LOGDEST=/home/makepkglogs#-- Packager: name/email of the person or organization building packages#PACKAGER="John Doe &lt;john@doe.com&gt;"#-- Specify a key to use for package signing#GPGKEY="" ########################################################################## COMPRESSION DEFAULTS##########################################################################COMPRESSGZ=(gzip -c -f -n)COMPRESSBZ2=(bzip2 -c -f)COMPRESSXZ=(xz -c -z -)COMPRESSLRZ=(lrzip -q)COMPRESSLZO=(lzop -q)COMPRESSZ=(compress -c -f) ########################################################################## EXTENSION DEFAULTS########################################################################### WARNING: Do NOT modify these variables unless you know what you are# doing.#PKGEXT='.pkg.tar.xz'SRCEXT='.src.tar.gz' 附录III：/etc/pacman.d/mirrorlist点击显示/隐藏内容 1234567891011121314151617181920#### Manjaro Linux custom mirrorlist## Generated on 2018-12-15 07:14#### Please use 'pacman-mirrors -id' to reset custom mirrorlist## Please use 'pacman-mirrors -c all' to reset custom mirrorlist## To remove custom config run 'pacman-mirrors -c all'## ## Country : ChinaServer = https://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$arch ## Country : China#Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch ## Country : China#Server = https://mirrors.sjtug.sjtu.edu.cn/manjaro/stable/$repo/$arch ## Country : China#Server = https://mirrors.zju.edu.cn/manjaro/stable/$repo/$arch 附录IV：.zshrc点击显示/隐藏内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# If you come from bash you might have to change your $PATH.# export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH="/home/elinuxboy/.oh-my-zsh" # Set name of the theme to load --- if set to "random", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME="ys" # Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME=random will cause zsh to load# a theme from this variable instead of looking in ~/.oh-my-zsh/themes/# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" ) # Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE="true" # Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE="true" # Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE="true" # Uncomment the following line to change how often to auto-update (in days).# export UPDATE_ZSH_DAYS=13 # Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS="true" # Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE="true" # Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION="true" # Uncomment the following line to display red dots whilst waiting for completion.# COMPLETION_WAITING_DOTS="true" # Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY="true" # Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"# or set a custom format using the strftime function format specifications,# see 'man strftime' for details.# HIST_STAMPS="mm/dd/yyyy"# 历史命令日期显示格式HIST_STAMPS="yyyy-mm-dd" # Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.# z命令快速跳转目录 x命令解压一切文件 命令行可以直接google plugins=( git z zsh-autosuggestions extract web-search zsh-syntax-highlighting ) source $ZSH/oh-my-zsh.sh # User configuration # export MANPATH="/usr/local/man:$MANPATH" # You may need to manually set your language environment# export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then# export EDITOR='vim'# else# export EDITOR='mvim'# fi # Compilation flags# export ARCHFLAGS="-arch x86_64" # ssh# export SSH_KEY_PATH="~/.ssh/rsa_id" # Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run `alias`.## Example aliases# alias zshconfig="mate ~/.zshrc"# alias ohmyzsh="mate ~/.oh-my-zsh"# autojump自动跳转插件. /usr/share/autojump/autojump.zsh #自动补全插件#source ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh # 自动更新的时间间隔，单位是天，这里设置 30 天更新一次export UPDATE_ZSH_DAYS=1 # zsh-syntax-highlighting语法高亮插件source $&#123;ZSH&#125;/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh # 设置 gcc/g++ 别名alias gcc='gcc -fdiagnostics-color=auto'alias g++='g++ -fdiagnostics-color=auto' # 设置 git 命令自动补全 ，如：git co+敲两次tab键#if [ -f ~/.git-completion.bash ]; then# . ~/.git-completion.bash#fi # 加载vgz驱动和utf8支持alias zhcon='zhcon --utf8' alias cat='bat' # 设置环境变量LFS#export LFS=/mnt/lfs]]></content>
      <categories>
        <category>Linux</category>
        <category>xfce</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>xfce</tag>
        <tag>踩坑记录</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-mint-xfce-19-踩坑记录]]></title>
    <url>%2FLinux%2FLinux-mint-xfce-19-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[创建系统快照创建系统快照是 Linux Mint 19 的重要建议，可以使用与更新管理器捆绑的 Timeshift 应用程序轻松完成创建与恢复。 这个阶段很重要，万一出现令人遗憾的事件，比如安装破坏系统的应用程序，你始终可以恢复到系统副本。 启用国内软件源将主要和基础两个镜像设置为国内的最快的镜像，这里用 ustc （科大）镜像： 设置 Redshift 保护眼睛健康Night Light 已迅速成为桌面操作系统和手持设备的一项必备功能。该功能有助于过滤蓝光，因而减轻视觉疲劳。你要做的就是启动 Redshift 应用程序（它默认安装），将其设置成自动启动。 设置防火墙Linux Mint 19 预装 UFW （简单防火墙）。你只要在菜单中搜索 ufw 并激活它。 卸载自带软件linux mint 会自带一些国内不常用的软件，需要卸载。 卸载自带音乐播放器 rhythmbox$ sudo apt remove rhythmbox 卸载自带即时通讯工具 hexchat$ sudo apt remove hexchat 卸载自带 libreoffice只卸载文字（libreoffice-writer）与表格（libreoffice-calc）和幻灯片（libreoffice-impress）： $ sudo apt remove libreoffice-impress libreoffice-writer libreoffice-calc 完全卸载，不要漏掉通配符“?”，否则无法清除/卸载全部 LibreOffice 软件包： $ sudo apt-get purge libreoffice? 卸载自带词典 xfce4-dict$ sudo apt remove xfce4-dict 安装常用软件安装 apt-fastapt-fast 是一款替代 apt-get 提升下载速度的软件，安装软件时，通过增加线程使下载软件速度加快。apt-fast 本身其实就是一个脚本，所以安装特别简单，都不需要编译的。 $ git clone https://github.com/ilikenwf/apt-fast.git $ cd apt-fast $ sudo ./quick-install.sh 也可以到/etc/apt-fast.conf自行修改，详情查看 apt-fast 的README.md文件。 注：脚本quick-install.sh会自动安装 aria2。 解决汉化不完全的问题全新安装的 linux mint 中文版即使完全安装了简体中文语言包也会有汉化不完全的问题。参照网上的解决办法： $ sudo apt-fast install language-pack-zh-hans language-pack-gnome-zh-hans libreoffice-l10n-zh-cn thunderbird-locale-zh-hans firefox-locale-zh-hans 安装中文输入法安装谷歌拼音输入法搜狗拼音好用是好用，就是问题太多，资源占用也比较大，所以使用谷歌拼音输入法。 使用软件管理器安装以下组件： 基础组件：fcitx 配置组件：fcitx-config-gtk 图标组件：fcitx-ui-classic 谷歌拼音：fcitx-googlepinyin $ sudo apt-fast install fcitx fcitx-config-gtk fcitx-ui-classic fcitx-googlepinyin 安装完成后注销或者重启即可。 提示：安装系统默认中文输入法后如果系统的字体显示会出现变化，下面会介绍解决办法。 #### 安装搜狗拼音输入法 到官网 https://pinyin.sogou.com/linux/?r=pinyin 下载，双击已下载的 deb 安装包 sogoupinyin_2.2.0.0108_amd64.deb，包管理器会解决依赖问题，然后自动安装。 安装中文字体 新建文件夹：/usr/share/fonts/myFontsFromWin10 复制 windows 10 下c:\Windows\Fonts\的字体 微软雅黑：msyh.ttc 微软雅黑：msyhbd.ttc 楷体：simkai.ttf 新宋体： simsun.ttc 黑体：simhei.ttf 仿宋：simfang.ttf 宋体：simsunb.ttf 到/usr/share/fonts/myFontsFromWin10目录下。 控制台进入/usr/share/fonts/myFontsFromWin10目录，执行 $ sudo mkfontale $ sudo mkfontdir 检查字体 $ fc-list | grep myFonts* 以后就可以方便设置和使用这些字体了，顺便解决安装系统默认输入法后字体变化问题。 安装谷歌浏览器 chrome从官网 https://www.google.com/chrome/ 下载，双击已下载的deb安装包google-chrome-stable_current_amd64.deb自动安装。 添加谷歌访问助手扩展插件打开 chrome，打开扩展程序，打开开发者模式，将已下载的文件“谷歌访问助手XXX.crx”拖到扩展程序页面，添加扩展程序即可。 安装多媒体插件Linux Mint 19 整合了多种媒体播放器，但仍缺少一些多媒体代码，因此播放某些媒体文件可能是个问题。运行下列命令来安装媒体插件，享受出色的电影观赏和音乐聆听体验。 $ sudo apt-fast install mint-meta-codecs 安装网易云音乐播放器官方版本（目前版本：netease-cloud-music_1.1.0_amd64_ubuntu.deb）的网易云音乐播放器有启动不了的 bug，网上修复也有很多问题，这里使用第三方的替代品 ieaseMusic。项目地址：https://github.com/trazyn/ieaseMusic。双击已下载的 deb 安装包ieaseMusic-1.3.2-linux-amd64.deb开始自动安装。 安装在线视频播放在线视频方面，Funplayer 更名为 Moonplayer（月亮播放器），而且一直在活跃更新中。目前已经较为成熟完善了，而且最近作者可能得到了某些志愿者美工的帮助，换了一套较为大气、漂亮的界面。站长薄荷君觉得非常有必要重新介绍一下 Linux 用户喜爱的“月亮播放器”。在 LinuxMint/Ubuntu 系列系统中，使用如下 PPA 安装月亮播放器： $ sudo add-apt-repository ppa:cos-lyk/moonsoft $ sudo apt-fast update $ sudo apt-fast install moonplayer 安装截图软件shutter可编辑的截图软件，使用软件管理器安装。 修复shutter不能使用编辑截图的问题安装了截图工具 Shutter 后，编辑按钮变成灰色。要重新启用“编辑”选项，Shutter 需要libgoo-canvas-perl库。使用已下载的 deb 包安装： libgoocanvas3_1.0.0-1_amd64.deb libgoocanvas-common_1.0.0-1_all.deb libgoo-canvas-perl_0.06-2ubuntu3_amd64.deb hotshots跨平台的截图工具。能添加文字、箭头、圆形、矩形、直线、贝塞尔曲线、图片、高亮荧光效果。如果不能用 shutter 编辑截图的话，就用 hotshots 替代。 安装录屏软件vokscreen使用软件管理器安装。 peekAUR 上人气很高的屏幕录像工具，小巧玲珑，可保存录像为 gif 动图和兼容于 html5 的 webm 视频。 使用软件管理器安装。 安装下载工具 uget$ sudo apt-fast install uget 配置 Chrome 调用 uGet 下载安装 uget-integrator$ sudo add-apt-repository ppa:uget-team/ppa $ sudo apt update $ sudo apt-fast install uget-integrator chrome 安装 uget 扩展在 chrome 应用商店搜索uGet Integration，添加即可。 安装翻译词典 goldendict强大的翻译软件，有离线词典（需要下载，然后添加）。使用软件管理器安装。 安装深度终端可分屏的终端模拟器。使用软件管理器安装。 安装 gnome 系统监视器较全面的任务管理器。使用软件管理器安装。 安装硬件信息查看工具使用软件管理器安装。 安装文件比较工具使用软件管理器安装。 安装即时通讯工具腾讯官方没有 linux 版本的 QQ 和微信客户端。只能使用第三方打包的软件。 QQ&amp;TIM 项目地址：https://github.com/askme765cs/Wine-QQ-TIM 微信项目地址：https://github.com/geeeeeeeeek/electronic-wechat 或者另外一个微信项目：https://github.com/trazyn/weweChat 安装 QQ使用已经下载的软件包：Wine-QQ.AppImage 创建快捷方式：/home/elinuxboy/.local/share/applications/wine-qq.desktop 内容如下（具体位置需要修改，其中图标需要另行下载）： 点击显示/隐藏内容 123456789101112131415[Desktop Entry]# 快捷方式的名称Name=QQ轻聊版# 注释Comment=Linux下QQ的替代品wine-qq.# AppImage qq所在的文件路径Exec=/mnt/backup/软件/linux/software/qq&amp;weixin/Wine-QQ.AppImage %UTerminal=false# 图标Icon=/mnt/backup/软件/linux/software/qq&amp;weixin/qq.png Type=ApplicationCategories=NetworkStartupNotify=trueTryExec=/mnt/backup/软件/linux/software/qq&amp;weixin/Wine-QQ.AppImageName[zh_CN]=QQ轻聊版 安装 TIM使用软件包 Wine-TIM.AppImage,快捷方式类同 qq 的快捷方式创建 安装微信 下载后解压缩 electronic-wechat-linux-x64.tar.gz。创建快捷方式与 QQ 类似。 安装远程桌面管理软件去官网 https://www.teamviewer.com/cn/ 下载deb安装包安装。 安装超酷的 cat 替代命令 bat项目地址：https://github.com/sharkdp/bat 使用已下载的 deb 包bat_0.8.0_amd64.deb安装。 安装编辑软件Sublime非常轻量、非常好用的代码编辑软件，使用软件管理器安装。 中文输入修复## Sublime Text 3 输入法(Fcitx)修复[Ubuntu(Debian)] + 修复 Sublime Text 3&apos;s 在 Ubuntu(Debian) 系统下的无法输入中文(CJK 字符)的问题 + 修复中文对齐问题 $ git clone https://github.com/lyfeyaj/sublime-text-imfix.git $ cd sublime-text-imfix $ sudo ./sublime-imfix 安装 git 图形界面GitKrakenAUR 里人气很高的一个 Git 客户端。使用软件管理器安装。 smartgit使用软件管理器安装。 SmartGit 过期破解找到并删除文件： ~/.smartgit/ 安装虚拟机 vmware workstations到官网下载。使用已下载的包VMware-Workstation-Full-14.1.1-7528167.x86_64.bundle。 在终端执行命令安装： $ sudo ./VMware-Workstation-Full-14.1.1-7528167.x86_64.bundle 安装办公软件 wps著名的国产 Office 套件，需要上wps官网下载。 使用已下载的 deb 包wps-office_10.1.0.6757_amd64.deb安装 解决 wps 提示字体缺失问题使用已下载的 deb 包symbol-fonts_1.2_all.deb安装。 安装 npm$ sudo apt-fast install npm 淘宝 npm国内使用 npm 太慢的话，可以使用淘宝 npm。淘宝 npm 地址： http://npm.taobao.org/ 临时使用$ npm --registry https://registry.npm.taobao.org install express 通过 cnpm 使用配置镜像$ npm install -g cnpm --registry=https://registry.npm.taobao.org 使用$ cnpm install express 更新升级系统$ sudo apt update $ sudo apt-fast upgrade -y 解决关机重启时间过长问题LinuxMint/Ubuntu 关机重启等待 90 秒问题的解决办法： 安装 watchdog $ sudo apt-fast install watchdog 开启 watchdog 服务 $ sudo systemctl enable watchdog.service 马上启用 watchdog 服务 $ sudo systemctl start watchdog.service 只需上述三步，关机等待 90 秒就消失了。 双系统时间同步装了 windows10 和 linux mint 19 双系统，仍然出现了喜闻乐见的老问题，装完后，在 windows 下时区不对。 方法一： $ sudo xed /etc/default/rcS 更改 utc=yes 改成 utc=no，如若没有此行，直接添加即可 方法二： $ sudo apt-fast install ntpdate $ sudo ntpdate time.windows.com 然后将时间更新到硬件上： $ sudo hwclock --localtime --systohc 重新进入 windows10，发现时间恢复正常了！ 清洁系统删除未完全安装的软件包： $ sudo apt autoclean 删除 apt-cache： $ sudo apt clean 删除不需要的软件依赖项： $ sudo apt autoremove 设置开始菜单（whisker 菜单）属性右键单击开始菜单》属性》行为》菜单》将菜单下的复选框全选上 效果如下： 将打开的窗口设置为扁平按钮右键单击面板》面板》面板首选项》项目》窗口管理》编辑当前选中的项目》外观》使用扁平按钮设置面板时间显示 右键单击面板》面板》面板选项》项目》时钟》编辑当前选中的项目》时钟选项》格式》自定义格式》将格式设置为：%Y 年 %m 月 %d 日 %T 使用 adb 连接 android 手机安装 adb$ sudo apt-fast install adb 新建文件 cat /etc/udev/rules.d/51-android.rules，添加如下内容： SUBSYSTEM==”usb”, ENV{DEVTYPE}==”usb_device”, MODE=”0666” 重启 udev $ sudo /etc/init.d/udev restart 将手机用数据线连接电脑，使用终端操作手机（需在手机上开启USB调试） $ adb shell #shell 支持兼容 32bit 程序要运行 32bit 的程序，需要安装如下库： $ sudo dpkg –add-architecture i386 $ sudo apt-fast install libc6:i386 lib32ncurses5 lib32stdc++6 ia32-libs lib32z1 开机挂载 windows 格式的硬盘注意：该步骤会导致开机变慢 linux mint 系统默认不会开机挂载其他分区，为了方便使用其他分区，需要设置开机挂载其他分区。开始菜单》附件》硬盘》选择硬盘》选择分区》其他分区选项》编辑挂载选项》设置挂载选项和挂载点。重启系统后会自动挂载了。]]></content>
      <categories>
        <category>Linux</category>
        <category>xfce</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mint</tag>
        <tag>xfce</tag>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表学习记录]]></title>
    <url>%2FDataStructuresAndAlgorithms%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[概念链接方式存储链接方式存储的线性表简称为链表（Linked List）。 链表的具体存储表示为： 用一组任意的存储单元来存放线性表的结点（这组存储单元既可以是连续的，也可以是不连续的）。 链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址（或位置）信息（称为指针（pointer）或链(link)）。 链式存储是最常用的存储方式之一，它不仅可用来表示线性表，而且可用来表示各种非线性的数据结构。 单链表 单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。 链表中的数据是以结点来表示的，每个结点的构成为： 元素(数据元素的映象，通常称为“数据域”) + 指针(指示后继元素存储位置，通常称为“指针域”)。 元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。 如图1所示，数据域data–存放结点值的数据域；指针域next–存放结点的直接后继的地址（位置）的指针域（链域）。 链表通过每个结点的链域将线性表的n个结点按其逻辑顺序链接在一起的，每个结点只有一个链域的链表称为单链表（Single Linked List）。 图1 链表结点的结构 头指针pHead、头结点pHeadNode、首元结点p1Node和终端结点（尾结点）pTailNode 头结点pHeadNode： 有时，在链表的第一个结点之前会额外增设一个结点，结点的数据域一般不存放数据（有些情况下也可以存放链表的长度等信息），此结点被称为头结点。 若头结点的指针域为空（NULL），表明链表是空表(如图2 所示)。头结点对于链表来说，不是必须的，在处理某些问题时，给链表添加头结点会使问题变得简单。 图2 空链表 头指针pHead： 永远指向链表中第一个结点的位置（如果链表有头结点，头指针指向头结点；否则，头指针指向首元结点）。 头结点和头指针的区别： 头指针是一个指针，头指针指向链表的头结点或者首元结点；头结点是一个实际存在的结点，它包含有数据域和指针域。两者在程序中的直接体现就是：头指针只声明而没有分配存储空间，头结点进行了声明并分配了一个结点的实际物理内存。 单链表中可以没有头结点，但是不能没有头指针！ 单链表中每个结点的存储地址是存放在其前趋结点next域中。 开始结点无前趋，故应设头指针pHead指向开始结点。 链表由头指针唯一确定，单链表可以用头指针的名字来命名。 首元结点p1Node： 链表中第一个元素所在的结点，如果存在头结点则它是头结点后边的第一个结点。如图 3 所示。 图3 非空链表 终端结点（尾结点）pTailNode: 终端结点（尾结点）无后继，故终端结点的指针域为空，即NULL。 单链表的定义C语言使用结构体来定义单链表： 点击显示/隐藏内容 1234567891011121314//定义结点数据域的类型typedef char DataType;//定义结点typedef struct Node&#123; DataType data;//数据域 struct Node *next;//指针域&#125;Node;//Node和SinglyLinkedList是不同名字的同一个类型（命名的不同是为了概念上更明确）typedef struct Node SinglyLinkedList;//显示定义SinglyLinkedList类型的指针变量*pHead表示它是单链表的头指针SinglyLinkedList *pHead; 单链表的建立初始化带头结点的单链表的初始化就是创建一个头结点，给他分配存储空间。并将头结点的指针域指向NULL。 点击显示/隐藏内容 123456789101112131415/*** 初始化单链表，创建一个带头结点的空链表* @return 链表头指针*/SinglyLinkedList *InitSinglyLinkedList()&#123; // 申请存储空间可使用malloc()函数实现，需设立一申请单元指针，这里是头指针pHead， // 但malloc()函数得到的指针并不是指向结构体的指针，因此，需使用强制类型转换， // 将其转换成结构体型指针。 pHead = (SinglyLinkedList *)malloc(sizeof(SinglyLinkedList)); // 刚开始时，链表还没建立，是一空链表，pHead结点的next指针为NULL。 pHead-&gt;next = NULL; return pHead;&#125; 单链表是用户不断申请存储单元和改变链接关系而得到的一种特殊数据结构，将链表的左边称为链头，右边称为链尾。 带头结点的单链表的创建有头插法、尾插法两种方法。 头插法头插法建单链表是将链表右端看成固定的，链表不断向左延伸而得到的。头插法最先得到的是尾结点。如图 4 所示： 图4 头插法 由于链表的长度是随机的，故用一个for循环来控制链表中结点个数。 申请存储空间可使用malloc()函数实现，需设立一申请单元指针，但malloc()函数得到的指针并不是指向结构体的指针，需使用强制类型转换，将其转换成结构体型指针。 刚开始时，链表还没建立，是一空链表，pHead指针为NULL。 链表建立的过程是申请空间、得到数据、建立链接的循环处理过程。 头插法实现代码如下： 点击显示/隐藏内容 12345678910111213141516171819202122232425262728/** * 头插法创建带头结点的单链表 * 如：pHead--&gt;d--&gt;c--&gt;b--&gt;a--&gt;NULL [逆序] * @param pHead 链表头指针 * @param pData 要插入数据的指针 * @param dataCount 要插入数据的数量 * @return 插入后链表的头指针 */ SinglyLinkedList * CreateListFrHead (SinglyLinkedList *pHead, DataType *pData, int dataCount) &#123; //创建一个搜索结点，用于遍历链表 SinglyLinkedList *pCurrent = pHead; for(int i = 0; i &lt; dataCount; i++) &#123; // 创建新结点pInsertNode用于存放要插入的数据 SinglyLinkedList *pInsertNode = (SinglyLinkedList *)malloc(sizeof(SinglyLinkedList)); pInsertNode-&gt;data = pData[i]; // 将pInsertNode插在原结点之前,前驱结点之后 // 因为每个结点的地址都是存放在其前驱结点的指针域next中 pInsertNode-&gt;next = pCurrent-&gt;next; //原结点之前 pCurrent-&gt;next = pInsertNode; //前驱节点结点之后 &#125; return pHead; &#125; 尾插法若将链表的左端固定，链表不断向右延伸，这种建立链表的方法称为尾插法。如图 5 所示： 图5 尾插法 尾插法建立链表时，头指针固定不动，故必须设立一个搜索指针，向链表右边延伸，则整个算法中应设立三个链表指针，即头指针pHead、搜索指针pCurrent、申请单元指针pInsertNode。尾插法最先得到的是头结点。 尾插法实现代码如下： 点击显示/隐藏内容 12345678910111213141516171819202122232425262728293031/** * 尾插法建立带头结点的单链表 * 例如：pHead--&gt;a--&gt;b--&gt;c--&gt;d--&gt;NULL [顺序] * @param pHead 链表头指针 * @param pData 要插入的数据指针 * @param dataCount 要插入的数据数量 * @return 插入后的链表头指针 */SinglyLinkedList * CreateListFrTail(SinglyLinkedList *pHead, DataType *pData, int dataCount) &#123; //创建搜索指针pCurrent用于遍历链表 SinglyLinkedList *pCurrent = pHead; //遍历链表 for (int i = 0; i &lt; dataCount; i++) &#123; //创建新结点pInsertNode用于保存要插入的数据 SinglyLinkedList *pInsertNode = (SinglyLinkedList *) malloc( sizeof(SinglyLinkedList)); pInsertNode-&gt;data = pData[i]; //将pInsertNode插入pCurrent之后 pCurrent-&gt;next = pInsertNode; //pCurrent始终指向尾结点 pCurrent = pInsertNode; &#125; //插入完成后，尾结点的next域置为NULL pCurrent-&gt;next = NULL; return pHead;&#125; 完整的测试代码如下点击显示/隐藏内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//定义结点数据域的类型typedef char DataType;//定义结点typedef struct Node &#123;​ DataType data; //数据域​ struct Node *next; //指针域&#125; Node;//定义SinglyLinkedList类型变量表示单链表//注意：Node和SinglyLinkedList是不同名字的同一个类型（命名的不同是为了概念上更明确）typedef struct Node SinglyLinkedList;//显示定义SinglyLinkedList类型的指针变量*pHead表示它是单链表的头指针SinglyLinkedList *pHead;/** * 初始化单链表，创建一个带头结点的空链表 * @return 链表头指针 */ SinglyLinkedList *InitSinglyLinkedList();/** * 判断链表是否为空 * @param pHead 链表头指针 * @return 1为空，0不为空 */ int IsEmpty(SinglyLinkedList *pHead);/** * 头插法创建带头结点的单链表 * 如：pHead--&gt;d--&gt;c--&gt;b--&gt;a [逆序] * @param pHead 链表头指针 * @param pData 要插入数据的指针 * @param dataCount 要插入数据的数量 * @return 插入后链表的头指针 */ SinglyLinkedList *CreateSinglyLinkedListFrHead(SinglyLinkedList *pHead, DataType *pData, ​ int dataCount);/** * 尾插法建立带头结点的单链表 * 例如：pHead--&gt;a--&gt;b--&gt;c--&gt;d--&gt;NULL [顺序] * @param pHead 链表头指针 * @param pData 要插入的数据指针 * @param dataCount 要插入的数据数量 * @return 插入后的链表头指针 */ SinglyLinkedList * CreateSinglyLinkedListFrTail(SinglyLinkedList *pHead, DataType *pData, ​ int dataCount);/** * 输出链表的长度 * @param pHead 链表头指针 * @return 链表中结点个数 */ int SinglyLinkedListLength(SinglyLinkedList *pHead);/** * 输出链表中的数据 * @param pHead 链表头指针 */ void DispSinglyLinkedList(SinglyLinkedList *pHead); int main(void) &#123;​ //带头结点的单链表初始化​ pHead = InitSinglyLinkedList(); //输出链表 DispSinglyLinkedList(pHead); //创建如下单链表 DataType *pData = "abcdefg"; //头插法创建链表 pHead = CreateSinglyLinkedListFrHead(pHead, pData, strlen(pData)); //尾插法创建链表 // pHead = CreateSinglyLinkedListFrTail(pHead, pData, strlen(pData)); printf("链表长度为：%d\n", SinglyLinkedListLength(pHead)); //输出链表 DispSinglyLinkedList(pHead); //释放存储空间 free(pHead); return EXIT_SUCCESS;&#125;/** * 初始化单链表，创建一个带头结点的空链表 * @return 链表头指针 */ SinglyLinkedList *InitSinglyLinkedList() &#123; // 申请存储空间可使用malloc()函数实现，需设立一申请单元指针，这里是头指针pHead， // 但malloc()函数得到的指针并不是指向结构体的指针，因此，需使用强制类型转换， // 将其转换成结构体型指针。 pHead = (SinglyLinkedList *) malloc(sizeof(SinglyLinkedList)); // 刚开始时，链表还没建立，是一空链表，pHead结点的next指针为NULL。 pHead-&gt;next = NULL; return pHead; &#125;/** * 判断链表是否为空 * @param pHead 链表头指针 * @return 1为空，0不为空 */ int IsEmpty(SinglyLinkedList *pHead) &#123; return (pHead-&gt;next == NULL); &#125;/** * 头插法创建带头结点的单链表 * 如：pHead--&gt;d--&gt;c--&gt;b--&gt;a--&gt;NULL [逆序] * @param pHead 链表头指针 * @param pData 要插入数据的指针 * @param dataCount 要插入数据的数量 * @return 插入后链表的头指针 */ SinglyLinkedList *CreateSinglyLinkedListFrHead(SinglyLinkedList *pHead, DataType *pData, ​ int dataCount) &#123; //创建一个搜索结点，用于遍历链表 SinglyLinkedList *pCurrent = pHead; for (int i = 0; i &lt; dataCount; i++) &#123; ​ // 创建新结点pInsertNode用于存放要插入的数据 ​ SinglyLinkedList *pInsertNode = (SinglyLinkedList *) malloc( ​ sizeof(SinglyLinkedList)); ​ pInsertNode-&gt;data = pData[i]; // 将pInsertNode插在原结点之前,前驱结点之后 // 因为每个结点的地址都是存放在其前驱结点的指针域next中 pInsertNode-&gt;next = pCurrent-&gt;next; //原结点之前 pCurrent-&gt;next = pInsertNode; //前驱节点结点之后 &#125; return pHead; &#125;/** * 尾插法建立带头结点的单链表 * 例如：pHead--&gt;a--&gt;b--&gt;c--&gt;d--&gt;NULL [顺序] * @param pHead 链表头指针 * @param pData 要插入的数据指针 * @param dataCount 要插入的数据数量 * @return 插入后的链表头指针 */ SinglyLinkedList * CreateSinglyLinkedListFrTail(SinglyLinkedList *pHead, DataType *pData, ​ int dataCount) &#123; //创建搜索指针pCurrent用于遍历链表 SinglyLinkedList *pCurrent = pHead; //遍历链表 for (int i = 0; i &lt; dataCount; i++) &#123; ​ //创建新结点pInsertNode用于保存要插入的数据 ​ SinglyLinkedList *pInsertNode = (SinglyLinkedList *) malloc( ​ sizeof(SinglyLinkedList)); ​ pInsertNode-&gt;data = pData[i]; //将pInsertNode插入pCurrent之后 pCurrent-&gt;next = pInsertNode; //pCurrent始终指向尾结点 pCurrent = pInsertNode; &#125; //插入完成后，尾结点的next域置为NULL pCurrent-&gt;next = NULL; return pHead; &#125;/** * 输出链表中的数据 * @param pHead 链表头指针 */ void DispSinglyLinkedList(SinglyLinkedList *pHead) &#123; if (IsEmpty(pHead)) &#123; ​ printf("链表为空！\n"); ​ return; &#125; //创建搜索结点pCurrent用于遍历链表 //因为头结点中不存放数据，所以需要跳过头结点 SinglyLinkedList *pCurrent = pHead-&gt;next; //遍历链表 while (pCurrent != NULL) &#123; ​ printf("%c ", pCurrent-&gt;data); ​ pCurrent = pCurrent-&gt;next; &#125; printf("\n"); &#125;/** * 输出链表的长度 * @param pHead 链表头指针 * @return 链表中结点个数 */ int SinglyLinkedListLength(SinglyLinkedList *pHead) &#123; int ListLength = 0; SinglyLinkedList *pCurrent = pHead; while (pCurrent-&gt;next != NULL) &#123; ​ ListLength++; ​ pCurrent = pCurrent-&gt;next; &#125; return ListLength; &#125; 未完待续。。。 参考 《百度百科——单链表》 《数据结构：单链表基本操作》 《数据结构与算法教程，数据结构C语言版教程！》]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>数据结构与算法</tag>
        <tag>学习记录</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习整理记录]]></title>
    <url>%2FDataStructuresAndAlgorithms%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[===注：此文由本人结合网上资源整理总结而来，仅代表个人的学习与理解，如有错漏，欢迎指正！=== 数据结构数据结构是什么？ 数据结构，直白地理解，就是研究数据的逻辑关系与存储方式的一门学科。 可以简单的分为：数据的逻辑结构（逻辑关系）和数据的存储结构（物理结构）。 它是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。 数据的逻辑结构 数据的逻辑结构，简单地理解，就是指的数据之间的逻辑关系。 数据之间的逻辑关系可简单的分为三类： 一对一 一对多 多对多 数据的存储结构 数据的存储结构，也就是物理结构，指的是数据在物理存储空间上的存放方式，可以选择集中存放，还是分散存放。 假设要存储大小为 10M 的数据，则集中存放就如图1（a）所示，分散存放就如图1（b）所示。 图1（a） 数据的集中存放 图1（b） 数据的分散存放 为什么要用数据结构？ 使用数据结构的目的，即方便对数据的利用和操作。 数据结构有哪些？根据数据的逻辑结构和存储结构，可以把数据结构分为三大类： 第一类：线性表，用于存储具有“一对一”逻辑关系的数据。包括顺序表、链表、栈和队列； 第二类：树结构，用于存储具有“一对多”逻辑关系的数据。包括普通树，二叉树，线索二叉树等； 第三类：图结构，用于存储具有“多对多”逻辑关系的数据； 如何使用数据结构？可以通过分析数据之间的逻辑关系来决定使用哪种存储结构，但具体使用顺序存储还是链式存储，还要通过数据的物理结构来决定。 如果选择集中存储，就使用顺序存储结构；反之，就使用链式存储。至于如何选择，主要取决于存储设备的状态以及数据的用途。 数据的用途不同，选择的存储结构也不同。将数据进行集中存储有利于后期对数据进行遍历操作，而分散存储更有利于后期增加或删除数据。因此，如果后期需要对数据进行大量的检索（遍历），就选择集中存储；反之，若后期需要对数据做进一步更新（增加或删除），则选择分散存储。 算法算法是什么： 算法，从表面意思来理解，即解决问题的方法。 算法是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。 在计算机中，算法是指解决方案的准确而完整的描述。 算法与程序算法是解决某个问题的想法、思路；而程序是在心中有算法的前提下编写出来的可以运行的代码。 某种程度上，算法相当于是程序的雏形。 当解决问题时，首先心中要有解决问题的算法，围绕算法编写出程序代码。 算法设计的要求 准确性、健壮性、运行效率（复杂度） 对于一个问题，想出解决的算法，不一定就能解决这个问题。为了避免这种情况的发生，要充分全面地思考问题，尽可能地考虑到所有地可能情况，慎重选择算法（需要在实践中不断地积累经验）。 算法的运行效率（复杂度）算法的运行效率（复杂度）体现在两方面： 算法的运行时间。（称为“时间复杂度”） 运行算法所需的内存空间大小。（称为“空间复杂度”） 拿时间换空间，用空间换时间算法的时间复杂度和空间复杂度是可以相互转化的。 比如：谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。 一个好算法的标准 在符合算法本身的要求（准确性和健壮性）的基础上，使用算法编写的程序运行的时间短，运行过程中占用的内存空间少，就可以称这个算法是“好算法”。 算法时间复杂度计算计算一个算法的时间复杂度，不可能把所有的算法都编写出实际的程序出来让计算机跑，这样会做很多无用功，效率太低。实际采用的方法是估算算法的时间复杂度。 程序（C语言）一般由三种结构构成：顺序结构、分支结构和循环结构。顺序结构和分支结构中的每段代码只运行一次；循环结构中的代码的运行时间要看循环的次数。 由于是估算算法的时间复杂度，相比而言，循环结构对算法的执行时间影响更大。所以，算法的时间复杂度，主要看算法中使用到的循环结构中代码循环的次数（称为“频度”）。次数越少，算法的时间复杂度越低。 时间复杂度的表示算法的时间复杂度的表示方式为： O(频度) 这种表示方式称为大“O”记法。——注意，是大写的字母O，不是数字0。 例如： 点击显示/隐藏内容 12345a) ++x; s=0;b) for (int i=1; i&lt;=n; i++) &#123; ++x; s+=x; &#125;c) for (int i=1; i&lt;=n; i++) &#123; for (int j=1; i&lt;=n; j++) &#123; ++x; s+=x; &#125; &#125; 上边这个例子中，a 代码的运行了 1 次，b 代码的运行了 n 次，c 代码运行了 n*n 次。 所以使用算法的时间复杂度表示为： a 的时间复杂度为O(1)，b 的时间复杂度为O(n)，c 的时间复杂度为为O(n2)。 如果把a、b、c三个例子组成一段程序，那么算法的时间复杂度为O(n2+n+1)。但这么表示是不对的，还需要对n2+n+1进行简化。 简化的过程总结为3步： 去掉运行时间中的所有加法常数。（例如 n2+n+1，直接变为 n2+n） 只保留最高项。（例如 n2+n 变成 n2） 如果最高项存在但是系数不是1，去掉系数。（例如 n2 系数为 1） 所以，最终a、b和c合并而成的代码的时间复杂度为O(n2)。 常用的时间复杂度的排序列举了几种常见的算法时间复杂度的比较（又小到大）： O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n2)平方阶 &lt; O(n3)(立方阶) &lt; O(2n) (指数阶) 数据结构与算法关系可以从分析问题的角度去理清数据结构和算法之间的关系。 通常，每个问题的解决都经过以下两个步骤： 第一步：分析问题，从问题中提取出有价值的数据，将其存储； 第二步：对存储的数据进行处理，最终得出问题的答案； 数据结构负责解决第一个问题，即数据的存储问题。针对数据不同的逻辑结构和物理结构，可以选出最优的数据存储结构来存储数据。而算法负责为剩下的第二个问题提供解决方案。 总而言之，数据结构用于解决数据存储问题，而算法用于处理和分析数据，它们是完全不同的两类学科。 参考 《数据结构与算法教程，数据结构C语言版教程！》 《数据结构与算法常见笔试题》]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>数据结构与算法</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
</search>
